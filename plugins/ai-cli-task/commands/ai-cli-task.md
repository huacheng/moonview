---
description: "Structured task lifecycle management with 13 skills for AI-driven development. Use when tasks need structured planning, domain-aware verification, and tracked execution through AiTasks/ directory workflow. Sub-commands: init, plan, research, check, verify, exec, merge, report, auto, cancel, list, annotate, summarize."
arguments:
  - name: subcommand
    description: "Sub-command: init, plan, research, check, verify, exec, merge, report, auto, cancel, list, annotate, summarize"
    required: true
  - name: args
    description: "Sub-command arguments (varies by sub-command)"
    required: false
---

# /moonview:ai-cli-task — Task Lifecycle Management

Single entry point for task lifecycle management in the `AiTasks/` directory.

## Arguments

{{ARGUMENTS}}

## Shared Context

### AiTasks/ Directory Convention

```
AiTasks/
├── .index.json                # Root index (task module listing, JSON array)
├── .type-registry.md          # Auto-expanding type registry (seed + discovered types, shared across tasks)
├── .plugin-registry.md        # Plugin capability cache (auto-maintained by delegation, see plugin-delegation.md)
├── .experiences/              # Cross-task knowledge base (by type, distilled from completed tasks)
│   ├── .summary.md            # Top-level index of all type directories (overwritten on each new entry)
│   └── <type>/                # One directory per task type
│       ├── .summary.md        # Condensed summary of all experiences for this type (overwritten on each new entry)
│       └── <module>.md        # Individual task experience (one file per completed task)
├── .references/               # External reference materials (by topic, collected by research sub-command)
│   ├── .summary.md            # Condensed index of all reference files (overwritten on each new entry)
│   └── <topic>.md             # One file per topic, kebab-case (e.g., express-middleware.md)
├── .type-profiles/            # Shared type profiles (auto-maintained by research/report for ALL types)
│   └── <type>.md              # Cross-task domain profile (methodology, verification, patterns, phase intelligence)
└── <module-name>/             # One directory per task module
    ├── .index.json            # Task metadata (JSON) — machine-readable
    ├── .target.md             # Requirements / objectives (human-authored)
    ├── .type-profile.md       # Domain methodology profile (research-informed, written by plan, updated by all phases)
    ├── .analysis/             # Evaluation history (one file per assessment by check)
    │   └── .summary.md        # Condensed summary of all evaluations (overwritten on each new entry)
    ├── .test/                 # Test criteria & results (one file per phase, by plan/exec/check)
    │   └── .summary.md        # Condensed summary of all criteria & results (overwritten on each new entry)
    ├── .bugfix/               # Issue history (one file per mid-exec issue by check)
    │   └── .summary.md        # Condensed summary of all issues & fixes (overwritten on each new entry)
    ├── .notes/                # Research notes & experience log (*-plan/*-exec suffix per origin)
    │   └── .summary.md        # Condensed summary of all research & decisions (overwritten on each new entry)
    ├── .summary.md            # Condensed context summary (written by plan/check/exec, read by all)
    ├── .report.md             # Completion report (written by report)
    ├── .tmp-annotations.json  # Transient annotation transport (frontend → annotate)
    ├── .auto-signal           # Transient auto-loop progress report (ephemeral)
    ├── .auto-stop             # Transient auto-loop stop request (ephemeral)
    ├── .auto-timeline.md      # Execution timeline (generated by backend on auto completion)
    ├── .plan.md               # Implementation plan (generated by plan, editable via Plan panel)
    └── .plan-superseded.md    # Archived plan on re-plan (renamed from .plan.md, suffixed if multiple)
```

- **Dot-prefixed** files are system-managed; `.target.md` and `.plan.md` are human-editable via the Plan annotation panel
- `.plan.md` is the implementation plan file, generated by `plan --generate` and editable through the Plan panel
- `.tmp-annotations.json`, `.auto-signal`, and `.auto-stop` are ephemeral (should be in `.gitignore`)
- `.notes/` files use origin suffix: `<YYYY-MM-DD>-<summary>-plan.md` or `<YYYY-MM-DD>-<summary>-exec.md`
- `.test/` files use phase prefix: `<YYYY-MM-DD>-<phase>-criteria.md` (test plan) or `<YYYY-MM-DD>-<phase>-results.md` (test outcomes)
- `.summary.md` is a condensed context file — written by `plan`/`check`/`exec` after each run, read by subsequent steps instead of all history files. Prevents context window overflow as task accumulates history
- Each history directory (`.analysis/`, `.test/`, `.bugfix/`, `.notes/`) contains a `.summary.md` that condenses all entries in that directory. **Overwritten** (not appended) each time a new entry is added to the directory. The task-level `.summary.md` integrates from these directory summaries rather than reading every individual file
- Global directories (`.experiences/`, `.references/`) also contain a `.summary.md` index — skills read it first to find relevant files by keyword, avoiding full directory scans

### .summary.md Format

`.summary.md` is overwritten (not appended) on each write. Recommended structure:

```markdown
# Task Summary: <title>

**Status**: <status> | **Phase**: <phase> | **Progress**: <completed_steps>/<total_steps>

## Plan Overview
<!-- 3-5 sentence summary of the implementation approach -->

## Current State
<!-- What was last done, what's next -->

## Key Decisions
<!-- Important architectural/design decisions made so far -->

## Known Issues
<!-- Active issues, blockers, or risks -->

## Lessons Learned
<!-- Patterns, workarounds, or discoveries from execution -->
```

Writers should keep `.summary.md` under ~200 lines. It is a context window optimization — not a full record (that's `.report.md`).

### Global Directory .summary.md Format

`.experiences/.summary.md` and `.references/.summary.md` serve as keyword indexes for fast file discovery. Skills read the relevant `.summary.md` first, match keywords, then drill into matched files.

> **See `commands/references/summary-formats.md`** for the detailed table formats (experiences index, per-type summaries, references index) and filename conventions.

### .index.json Schema

```json
{
  "title": "Human-readable task title",
  "type": "",
  "status": "draft",
  "phase": "",
  "completed_steps": 0,
  "created": "2024-01-01T00:00:00Z",
  "updated": "2024-01-01T00:00:00Z",
  "depends_on": [],
  "tags": [],
  "branch": "task/module-name",
  "worktree": ".worktrees/task-module-name"
}
```

Notes: `worktree` is empty string `""` if not using worktree. `depends_on` entries can be simple strings (require `complete`) or objects `{ "module": "...", "min_status": "..." }`.

#### Type Field

The `type` field identifies the task's domain. It is **auto-discovered** by `research` during the first `plan` phase — `init` does not accept a `--type` argument. All subsequent sub-commands (`check`, `exec`) read this field to adapt their behavior.

**Type format**: Single type (`software`) or pipe-separated hybrid (`data-pipeline|ml`). Parsing: `type.split('|')` → `[0]` is primary, `[1:]` are secondary domains.

**Seed types**: Predefined types are maintained in `init/references/seed-types/` directory (one file per type, with `.summary.md` index, ordered by scope broadest→most specialized) and used to initialize `AiTasks/.type-registry.md` on first `init`. Each per-type file contains Phase Intelligence (plan/verify/check/exec methodology). The registry is auto-expanded by `research` when new domains are discovered. See `init/references/seed-types/.summary.md` for the full index (14 seed files covering 19 types: software, science:*, documentation, data-pipeline, infrastructure, ml, ai-skill, image-processing, video-production, dsp, literary, screenwriting, mechatronics, chip-design).

Scientific research types follow [arXiv taxonomy](https://arxiv.org/category_taxonomy) — use `science:<domain>` for unlisted fields (e.g., `science:astro`, `science:neuro`, `science:materials`).

**Auto-discovery**: Type is determined automatically by `research` during the first `plan` phase (see `plan/references/type-profiling.md`). Research analyzes `.target.md` + web search to identify the domain, detects hybrid indicators, and writes the type to `.index.json`. No user input is needed — `init` creates tasks with `type: ""`, which `research` fills in.

**Auto-expanding registry**: `AiTasks/.type-registry.md` holds all known types (seed + dynamically discovered). When `research` identifies a domain not in the registry, it appends a new row automatically. The predefined table above is a **seed**, not a ceiling — new domains are registered on demand.

**Hybrid types**: Tasks spanning multiple domains use pipe-separated format (e.g., `data-pipeline|ml`). The first segment is primary (drives architecture), subsequent segments are secondary (add domain-specific verification and implementation concerns). All phases read experience files and apply methodology for **all** segments.

**Type profile**: Every task module gets a `.type-profile.md` during planning. This file is the **authoritative** domain methodology source for the task — all phases (verify, check, exec) read it first, before falling back to static reference tables. The profile is updated progressively as research/verify/check/exec discover new domain information.

**Type field validation**: Each pipe-separated segment must match `[a-zA-Z0-9_:-]+`. Full type field regex: `[a-zA-Z0-9_:|-]+`. `plan` MUST validate before writing to `.index.json`. `report` MUST validate before using as `.experiences/<type>/` directory name to prevent path traversal.

**Directory-safe transform**: When using a type segment as a directory name (e.g., `.experiences/<segment>/`, `.type-profiles/<segment>.md`), replace `:` with `-` (e.g., `science:astro` → `science-astro`). The original type value in `.index.json` is unchanged. **Collision note**: avoid registering types whose names differ only by `:` vs `-` (e.g., `science-astro` and `science:astro` both map to `science-astro/`). The type registry should treat these as the same type.

**Unknown type handling**: When `check` or `exec` encounters a `type` value not matching any known domain in the reference tables, it reads `.type-profile.md` for task-specific methodology. If `.type-profile.md` also doesn't exist (legacy task), it falls back to `software` methodology and records a warning in `.analysis/` (check) or `.notes/` (exec).

#### Phase Field

The `phase` field disambiguates sub-states within a status, primarily for `re-planning` auto recovery:

| Status | Phase | Meaning | Auto Entry Action |
|--------|-------|---------|-------------------|
| `re-planning` | `needs-plan` | check REPLAN set status, plan hasn't run yet | `plan --generate` |
| `re-planning` | `needs-check` | plan regenerated, ready for assessment | `verify` → `check --checkpoint post-plan` |
| (other) | `""` (empty) | No sub-state needed | Status-based routing |

Writers: `check` sets `phase: needs-plan` on REPLAN and on NEEDS_REVISION when status is `re-planning`. `plan` sets `phase: needs-check` when completing on `re-planning` status. `annotate` sets `phase: needs-check` when the new status is `re-planning` (same rule as `plan`). All other transitions clear `phase` to `""`.

### Status State Machine

| Status | Description | Transitions To |
|--------|-------------|----------------|
| `draft` | Task target being defined | `planning`, `cancelled` |
| `planning` | Plan being researched | `review`, `blocked`, `cancelled` |
| `review` | Plan passed assessment | `executing`, `re-planning`, `cancelled` |
| `executing` | Implementation in progress | `complete`, `re-planning`, `blocked`, `cancelled` |
| `re-planning` | Plan being revised | `review`, `blocked`, `cancelled` |
| `complete` | Finished and verified | — (terminal) |
| `blocked` | Blocked by dependency/issue | `planning`, `cancelled` |
| `cancelled` | Abandoned (via `cancel`) | — (terminal) |

> **See `commands/references/state-matrix.md`** for the complete state × command matrix with all (state, sub-command) combinations and verification properties.

### Annotation Format (for `annotate` sub-command)

> **See `commands/references/annotation-format.md`** for the `.tmp-annotations.json` schema — four annotation types (Insert/Delete/Replace/Comment) with context_before/context_after positioning.

### depends_on Format

Simple string `"module"` → requires `complete`. Extended object `{ "module", "min_status" }` → requires at-or-past that status. `exec`/`merge` MUST validate before proceeding; `check` flags unmet as BLOCKED.

> **See `commands/references/depends-on-format.md`** for full format specification, status progression order, and enforcement rules.

### Git Integration

Every task module has a dedicated git branch. Worktrees are optional for parallel execution.

#### Branch Convention

| Item | Format | Example |
|------|--------|---------|
| Branch name | `task/<module-name>` | `task/auth-refactor` |
| Worktree path | `.worktrees/task-<module-name>` | `.worktrees/task-auth-refactor` |

#### Commit Message Convention

All ai-cli-task triggered commits use `--` prefix to distinguish from user manual commits:

```
ai-cli-task(<module>):<type> <description>
```

| type | Scenario | Commit Scope |
|------|----------|-------------|
| `init` | Task initialization | AiTasks/ directory files |
| `plan` | Plan generation | AiTasks/ directory files |
| `check` | Check evaluation results | AiTasks/ directory files |
| `research` | Reference collection | AiTasks/.references/ files |
| `verify` | Test execution and verification | AiTasks/ directory files |
| `annotate` | Annotation processing | AiTasks/ directory files |
| `summarize` | Context summary regeneration | AiTasks/ directory files |
| `exec` | Execution state changes | AiTasks/ directory files |
| `feat` | New feature code during exec | Project files |
| `fix` | Bugfix code during exec | Project files |
| `refactor` | Code cleanup before merge | Project files |
| `merge` | Merge to main + conflict resolution | — (merge commit) |
| `report` | Report generation | AiTasks/ directory files |
| `cancel` | Task cancellation | AiTasks/ directory files |

Commit scope: AiTasks/ directory files (state/plan) or project files (feat/fix).

> **See `commands/references/git-details.md`** for commit examples, worktree parallel execution, rollback, and refactoring/merge workflow.

#### .auto-signal Convention

Every sub-command that participates in the automation loop (plan, check, exec, merge, report, research, verify, annotate) MUST write `.auto-signal` on completion, regardless of whether auto mode is active. Utility sub-commands (list, summarize) do NOT write `.auto-signal`:

```json
{
  "step": "<sub-command>",
  "result": "<outcome>",
  "next": "<next sub-command or (stop)>",
  "checkpoint": "<checkpoint hint for next command, optional>",
  "timestamp": "<ISO 8601>"
}
```

- The `next` field follows the signal routing table documented in the `auto` sub-command.
- The `checkpoint` field provides context for the next command (e.g., `"post-plan"`, `"mid-exec"`, `"post-exec"`) when the `next` command needs it. Optional — omit when not applicable. If auto mode is not active, the file is harmless (gitignored, ephemeral). This fire-and-forget pattern avoids each skill needing to detect auto mode.
- **Atomic write**: `.auto-signal` MUST be written atomically — write to `.auto-signal.tmp` first, then `rename` to `.auto-signal`. POSIX `rename` is atomic, preventing the daemon from reading partially written JSON.

**Worktree note**: In worktree mode, `.auto-signal` MUST be written to the **main worktree's** `AiTasks/<module>/` directory (not the task worktree copy) to survive worktree removal during merge cleanup.

#### .gitignore

Add to project `.gitignore`:
```
.worktrees/
AiTasks/**/.tmp-annotations.json
AiTasks/**/.auto-signal
AiTasks/**/.auto-signal.tmp
AiTasks/**/.auto-stop
AiTasks/**/.lock
AiTasks/.experiences/.lock
AiTasks/.references/.lock
AiTasks/.type-profiles/.lock
```

### Computation Rule

**No mental math.** When ANY sub-command involves numerical reasoning — performance estimates, size calculations, capacity limits, threshold comparisons, algorithm parameters, benchmarks, option evaluation — write a script and run it in shell instead of computing mentally. Scripts produce verifiable, reproducible results.

---

## Input Validation

All sub-commands that accept `<task_module>` MUST validate the path before processing:

| Check | Rule | Example |
|-------|------|---------|
| **Path containment** | Resolved path must be under `AiTasks/` directory (no `..` traversal) | `AiTasks/../etc/passwd` → REJECT |
| **Module name** | Must match `[a-zA-Z0-9_-]+` (ASCII letters/digits/hyphens/underscores only) | `auth-refactor` ✓, `../../foo` ✗ |
| **No symlinks** | Task module directory must not be a symlink (prevent symlink-based escape) | REJECT if `lstat` ≠ `stat` |
| **Existence** | Directory must exist (except for `init` which creates it) | REJECT if missing |
| **User text sanitization** | All user-provided text written to `.index.json` or `.md` files (e.g., `--title`, `--reason`, `--tags`) must be sanitized: strip HTML comments (`<!-- ... -->`), ANSI escape sequences, and control characters (except `\n`). This prevents hidden content injection when values appear in `.summary.md` or other markdown files | Sanitize before write |

Validation is performed by resolving the absolute path and confirming it starts with the project's `AiTasks/` prefix. This prevents path traversal attacks where a crafted module name could read/write files outside the task directory.

### Concurrency Protection

Without worktree mode, only one task should be actively operated at a time. Sub-commands that modify state (`plan`, `exec`, `check`, `merge`) MUST check for an active lockfile (`AiTasks/<module>/.lock`) before proceeding:

1. **Acquire**: Attempt to create `AiTasks/<module>/.lock` with `O_CREAT | O_EXCL` (atomic create-if-not-exists). Write `{ session, pid, timestamp }` to identify the holder
2. **If lock exists**: Read lock content, check if holding process is still alive (kill -0). If dead → remove stale lock and retry. If alive → REJECT with error identifying the holding session. No retry — the caller (user or auto) decides whether to retry
3. **Release**: Delete `.lock` on sub-command completion (including error paths)
4. **Worktree mode**: Lock not required — each worktree has its own copy of AiTasks/ files
5. **Stale lock recovery**: Use rename-based recovery instead of delete+create. When detecting a stale lock (holder dead): `rename` the stale `.lock` to `.lock.stale.<pid>`, then acquire normally with `O_CREAT | O_EXCL`. If the rename fails (another process already recovered), retry from step 1. Clean up ALL `.lock.stale.*` files in the same directory immediately after successful lock acquisition

### Shared Directory Write Protection

Three shared directories require locks before writing (all use the same lock protocol as module locks above):

| Directory | Lock File | Writers | Scope |
|-----------|-----------|---------|-------|
| `.experiences/<type>/` | `.experiences/.lock` | `report` | Create type dir, write `<module>.md`, update per-type and top-level `.summary.md`. For hybrid types (`A\|B`), covers all segments |
| `.references/` | `.references/.lock` | `research`, `exec` | Write `<topic>.md`, update `.summary.md` |
| `.type-profiles/` | `.type-profiles/.lock` | `research`, `report` | Write `<type>.md` shared profiles |

### .index.json Safety

**Atomic write**: All sub-commands that modify `.index.json` MUST write atomically — write to `.index.json.tmp` first, then `rename` to `.index.json`. POSIX `rename` is atomic, preventing concurrent readers from seeing partially written JSON.

**Corruption recovery**: If `.index.json` fails to parse (malformed JSON):

1. **Git recovery**: `git show HEAD:AiTasks/<module>/.index.json` — restore from latest committed version
2. **If git recovery fails**: Reconstruct minimal `.index.json` with `"status": "draft"`, `"phase": ""`, preserve only what's parseable
3. **Log**: Record corruption event and recovery action in `.analysis/<date>-index-recovery.md`

### Plugin Delegation (Extension Point)

Lifecycle skills can discover and delegate to system-installed external plugins at runtime, following the protocol in `auto/references/plugin-delegation.md`. Capability slots include: `doc-parse`, `brainstorm`, `code-review`, `frontend-design`, `debugging`, `tdd`, and `domain-*` (open-ended). Delegation executes through Task subagent isolation — the main context receives only a <=500 char summary. All delegation is optional: when no matching plugin is found, skills fall back to their existing inline logic. Discovered capabilities are cached in `AiTasks/.plugin-registry.md` for faster future matching.

### Model Routing (Extension Point)

Sub-commands have different cognitive demands. Each SKILL.md frontmatter declares `model_tier` (heavy/medium/light) and `auto_delegatable` (true/false) to enable the auto loop to dispatch lighter sub-commands to cheaper/faster model tiers via Task subagent.

> **See `commands/references/model-routing.md`** for tier definitions, the full routing table for all 13 skills, and the auto mode delegation protocol.

### Lifecycle Hooks (Extension Point)

Status transitions can optionally trigger external notifications via `AiTasks/.hooks.md`. Hooks are best-effort — failures do not block status transitions.

> **See `commands/references/lifecycle-hooks.md`** for hook configuration format, implementation details, and environment variables.

---

## Sub-commands

> Each sub-command's core logic is in `skills/<name>/SKILL.md`. Reference material is in `skills/<name>/references/` and loaded on demand.

### Skill File Structure

```
skills/<name>/
├── SKILL.md                # Core logic: steps, state transitions, signals, git
└── references/             # On-demand reference material (loaded when needed)
    └── *.md                # Domain guidelines, annotation processing, audit frameworks, etc.
```

Per-type seed methodology files are centralized in `skills/init/references/seed-types/` (one file per type, with `.summary.md` index). Each per-type file contains Phase Intelligence for all 4 lifecycle phases (plan/verify/check/exec), structured to mirror `.type-profile.md`.

**Main SKILL.md** contains the workflow: prerequisites, execution steps, state transitions, git conventions, `.auto-signal` definitions, and notes. It should be self-sufficient for understanding the sub-command's behavior.

**references/** contains large reference tables and domain-specific details that are only needed in specific situations. The main SKILL.md references these files with `See references/<file>.md` directives — Claude reads them on demand when the context requires it.

13 sub-commands: `init`, `plan`, `research`, `check`, `verify`, `exec`, `merge`, `report`, `auto`, `cancel`, `list`, `annotate`, `summarize`. Each skill's SKILL.md frontmatter contains the authoritative description, arguments, model tier, and delegation flag. Read `skills/<name>/SKILL.md` for full details.
